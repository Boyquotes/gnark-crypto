import (
	"math/bits"
	{{ template "import_fr" . }}
)

// BitReverse applies the bit-reversal permutation to a.
// len(a) must be a power of 2 (as in every single function in this file)
func BitReverse(a []fr.Element) {
	n := uint64(len(a))
	nn := uint64(64 - bits.TrailingZeros64(n))

	for i := uint64(0); i < n; i++ {
		irev := bits.Reverse64(i) >> nn
		if irev > i {
			a[i], a[irev] = a[irev], a[i]
		}
	}
}



func deriveLogTileSize(logN uint64) uint64 {
	q := uint64(9)

	for int(logN)-int(2*q) <= 0 {
		q--
	}

	return q
}

func BitReverseCobraInPlace(buf []fr.Element) {
	// TODO @gbotrel do a switch on the len(buf)
	bitReverseCobraInPlace(buf)
}

func bitReverseCobraInPlace(buf []fr.Element) {
	logN := uint64(bits.Len64(uint64(len(buf))) - 1)
	logTileSize := deriveLogTileSize(logN)
	logBLen := logN - 2*logTileSize
	bLen := uint64(1) << logBLen
	bShift := logBLen + logTileSize
	tileSize := uint64(1) << logTileSize

	t := make([]fr.Element, tileSize*tileSize)

	for b := uint64(0); b < bLen; b++ {

		for a := uint64(0); a < tileSize; a++ {
			aRev := bits.Reverse64(a) >> (64 - logTileSize)
			for c := uint64(0); c < tileSize; c++ {
				tIdx := (aRev << logTileSize) | c
				idx := (a << (bShift)) | (b << logTileSize) | c
				t[tIdx] = buf[idx]
			}
		}

		bRev := bits.Reverse64(b) >> (64 - logBLen)

		for c := uint64(0); c < tileSize; c++ {
			cRev := bits.Reverse64(c) >> (64 - logTileSize)
			for aRev := uint64(0); aRev < tileSize; aRev++ {
				a := bits.Reverse64(aRev) >> (64 - logTileSize)
				idx := (a << (bShift)) | (b << logTileSize) | c
				idxRev := (cRev << (bShift)) | (bRev << logTileSize) | aRev
				if idx < idxRev {
					tIdx := (aRev << logTileSize) | c
					buf[idxRev], t[tIdx] = t[tIdx], buf[idxRev]
				}
			}
		}

		for a := uint64(0); a < tileSize; a++ {
			aRev := bits.Reverse64(a) >> (64 - logTileSize)
			for c := uint64(0); c < tileSize; c++ {
				cRev := bits.Reverse64(c) >> (64 - logTileSize)
				idx := (a << (bShift)) | (b << logTileSize) | c
				idxRev := (cRev << (bShift)) | (bRev << logTileSize) | aRev
				if idx < idxRev {
					tIdx := (aRev << logTileSize) | c
					buf[idx], t[tIdx] = t[tIdx], buf[idx]
				}
			}
		}
	}
}


{{bitReverseCobraInPlace 8 21}}
{{bitReverseCobraInPlace 9 21}}
{{bitReverseCobraInPlace 9 22}}
{{bitReverseCobraInPlace 9 23}}
{{bitReverseCobraInPlace 9 24}}
{{bitReverseCobraInPlace 9 25}}
{{bitReverseCobraInPlace 9 26}}
{{bitReverseCobraInPlace 9 27}}


func BitReverseNew(buf []fr.Element) {
	switch len(buf) {
	case 1 << 21:
		bitReverseCobraInPlace_9_21(buf)
	case 1 << 22:
		bitReverseCobraInPlace_9_22(buf)
	case 1 << 23:
		bitReverseCobraInPlace_9_23(buf)
	case 1 << 24:
		bitReverseCobraInPlace_9_24(buf)
	case 1 << 25:
		bitReverseCobraInPlace_9_25(buf)
	case 1 << 26:
		bitReverseCobraInPlace_9_26(buf)
	case 1 << 27:
		bitReverseCobraInPlace_9_27(buf)
	default:
		BitReverse(buf)
	}
}


{{define "bitReverseCobraInPlace logTileSize logN"}}

func bitReverseCobraInPlace_{{.logTileSize}}_{{.logN}}(buf []fr.Element) {
	const (
		logTileSize = uint64({{.logTileSize}})
		tileSize = uint64(1) << logTileSize
		logN = {{.logN}}
		logBLen = logN - 2*logTileSize
		bShift = logBLen + logTileSize
		bLen = uint64(1) << logBLen
	)

	var t [tileSize * tileSize]fr.Element
	{{$k := sub 64  .logTileSize}}
	{{$l := .logTileSize}}
	{{$tileSize := shl 1 .logTileSize}}
	
	for b := uint64(0); b < bLen; b++ {
		bRev := bits.Reverse64(b) >> (64 - logBLen)

		for a := uint64(0); a < tileSize; a++ {
			aRev := bits.Reverse64(a) >> {{$k}}
			for c := uint64(0); c < tileSize; c++ {
				tIdx := (aRev << logTileSize) | c
				idx := (a << (bShift)) | (b << logTileSize) | c
				t[tIdx] = buf[idx]
			}
		}

		for c := uint64(0); c < tileSize; c++ {
			cRev := bits.Reverse64(c) >> {{$k}}
			for aRev := uint64(0); aRev < tileSize; aRev++ {
				a := bits.Reverse64(aRev) >> {{$k}}
				idx := (a << (bShift)) | (b << logTileSize) | c
				idxRev := (cRev << (bShift)) | (bRev << logTileSize) | aRev
				if idx < idxRev {
					tIdx := (aRev << logTileSize) | c
					buf[idxRev], t[tIdx] = t[tIdx], buf[idxRev]
				}
			}
		}

		for a := uint64(0); a < tileSize; a++ {
			aRev := bits.Reverse64(a) >> {{$k}}
			for c := uint64(0); c < tileSize; c++ {
				cRev := bits.Reverse64(c) >> {{$k}}
				idx := (a << (bShift)) | (b << logTileSize) | c
				idxRev := (cRev << (bShift)) | (bRev << logTileSize) | aRev
				if idx < idxRev {
					tIdx := (aRev << logTileSize) | c
					buf[idx], t[tIdx] = t[tIdx], buf[idx]
				}
			}
		}
	}

	
}

{{- end}}